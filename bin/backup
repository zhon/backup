#!/usr/bin/env ruby

source_root = File.expand_path(File.dirname(__FILE__) + "/..")
$LOAD_PATH.unshift("#{source_root}/lib")

require 'backup'

require 'thor'

require 'io/console'

# Find the backup drive in /Volumes
# Check diff with Media to see if you can do a --delete
# Backup to 
#

class CLI < Thor
  BACK_UP_ROOT = Backup::DriveFinder::BACK_UP_ROOT
  BACK_UP_EXT = Backup::DriveFinder::BACK_UP_EXT
  SOURCE_DIR_ROOT = "/Volumes/Media/"
  @@command = %w{rsync -av --exclude .DS_STORE }

  desc "backup", "from #{SOURCE_DIR_ROOT} to #{BACK_UP_ROOT}#{BACK_UP_EXT}"
  option 'dry-run', alias: '-d', type: :boolean, desc: "perform a trial run with no changes made"
  option :delete, desc: 'delete extraneous files from dest dirs'
  option :dest, desc: 'backup to this distination'
  def backup
    begin
      backup_disks = Backup::DriveFinder.new(options[:dest]).dirs

      commands = []
      backup_disks.each do |item|
        source = Backup::Mapper.new.find_src(item)
        commands.push(@@command + opts(item) + [source, item])
      end

      puts commands.map {|item| item.join ' '}.join
      print "Continue (Y/n): "
      if STDIN.getch == 'n'
        puts
        exit 1
      end
      puts

      pids = []
      commands.each do |item|
        pids << spawn(*item)
      end

      pids.each do |item|
        Process.wait item
      end

    rescue Backup::Error => err
      p err.message
      exit 1
    end

  end

  no_commands do

    def opts(backup_disk)
      opts = []
      if options["dry-run"]
        opts << "--dry-run"
      end
      if options[:delete]
        opts += %W{--delete --backup --backup-dir=#{backup_disk}/trash}
      end
      opts
    end

  end

  default_task :backup

end


CLI.start
